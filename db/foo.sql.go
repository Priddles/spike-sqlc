// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: foo.sql

package db

import (
	"context"

	"foo/ewkb"
	"github.com/google/uuid"
)

const createFoo = `-- name: CreateFoo :one
INSERT INTO foo (id, location)
VALUES ($1, $2)
RETURNING id, area, location
`

type CreateFooParams struct {
	ID       uuid.UUID  `db:"id" json:"id"`
	Location ewkb.Point `db:"location" json:"location"`
}

func (q *Queries) CreateFoo(ctx context.Context, arg CreateFooParams) (Foo, error) {
	row := q.db.QueryRow(ctx, createFoo, arg.ID, arg.Location)
	var i Foo
	err := row.Scan(&i.ID, &i.Area, &i.Location)
	return i, err
}

const getFoo = `-- name: GetFoo :one
SELECT id, area, location FROM foo WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFoo(ctx context.Context, id uuid.UUID) (Foo, error) {
	row := q.db.QueryRow(ctx, getFoo, id)
	var i Foo
	err := row.Scan(&i.ID, &i.Area, &i.Location)
	return i, err
}

const listFoos = `-- name: ListFoos :many
SELECT id,
    (CASE WHEN $1::boolean THEN area ELSE null END)::geom_any as area,
    (CASE WHEN $1::boolean THEN location ELSE null END)::geom_point as location
FROM foo
WHERE location && $2::geom_bound
`

type ListFoosParams struct {
	ReturnGeometry bool       `db:"return_geometry" json:"returnGeometry"`
	Bound          ewkb.Bound `db:"bound" json:"bound"`
}

type ListFoosRow struct {
	ID       uuid.UUID  `db:"id" json:"id"`
	Area     ewkb.Any   `db:"area" json:"area"`
	Location ewkb.Point `db:"location" json:"location"`
}

// The use of the CASE statement to conditionally select the spatial columns confuses sqlc, so type
// casting is used to inform which Go types should be used in the generated code. Without the type
// casts, sqlc falls back to interface{}.
func (q *Queries) ListFoos(ctx context.Context, arg ListFoosParams) ([]ListFoosRow, error) {
	rows, err := q.db.Query(ctx, listFoos, arg.ReturnGeometry, arg.Bound)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFoosRow{}
	for rows.Next() {
		var i ListFoosRow
		if err := rows.Scan(&i.ID, &i.Area, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
